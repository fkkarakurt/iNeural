<div class="content">
  <canvas> Your Browser Don't Support Canvas, Please Download Chrome`</canvas>
  <div class="centered">
    <h2>Coming Soon</h2>
    <h1>iNeural</h1>
  </div>
</div>

<style>
  * {
    box-sizing: border-box;
  }

  html,
  body {
    height: 100%;
    margin: 0;
    padding: 0;
    background-color: #333;
    color: white;
    overflow: hidden;
    font-family: "Source Sans Pro", sans-serif;
  }

  h1 {
    font-size: 32px;
    margin-top: 10px;
    margin-bottom: 40px;
  }
  h2 {
    font-size: 14px;
    margin: 0;
    font-weight: 300;
  }

  .content {
    display: flex;
    flex-direction: column;
    justify-content: center;
    width: 100%;
    height: 100%;
  }
  .centered {
    z-index: 1;
    position: relative;
    text-align: center;
    margin-top: -120px;
  }
  canvas {
    background: radial-gradient(ellipse at center, #a7c5db 0%, #2c3c48 100%);
    position: absolute;
    z-index: 0;
  }
</style>

<script>
  var canvasBody = document.querySelector("canvas"),
    canvas = canvasBody.getContext("2d"),
    w = (canvasBody.width = window.innerWidth),
    h = (canvasBody.height = window.innerHeight),
    tick = 0,
    opts = {
      backgroundColor: "white",
      particleColor: "#fcfcfc",
      opacity: 0.2,
      particleAmount: 60,
      defaultSpeed: 0.1,
      addedSpeed: 0.1,

      defaultRadius: 2,
      addedRadius: 10,

      communicationRadius: 150,
    },
    particles = [],
    Particle = function (Xpos, Ypos) {
      this.x = Xpos ? Xpos : Math.random() * w;
      this.y = Ypos ? Ypos : Math.random() * h;
      this.speed = opts.defaultSpeed + Math.random() * opts.addedSpeed;
      this.directionAngle = Math.floor(Math.random() * 360);
      this.color = opts.particleColor;
      this.radius = opts.defaultRadius + Math.random() * opts.addedRadius;
      if (this.radius >= 5) {
        this.shrinkOrGrow = "shrink";
      } else {
        this.shrinkOrGrow = "grow";
      }
      this.d = {
        x: Math.cos(this.directionAngle) * this.speed,
        y: Math.sin(this.directionAngle) * this.speed,
      };
      this.update = function () {
        this.border();
        this.x += this.d.x;
        this.y += this.d.y;
        if (this.shrinkOrGrow == "shrink") {
          this.radius -= 0.02;
        }
        if (this.shrinkOrGrow == "grow") {
          this.radius += 0.02;
        }
        if (this.radius <= opts.defaultRadius) {
          this.shrinkOrGrow = "grow";
        }
        if (this.radius >= opts.addedRadius) {
          this.shrinkOrGrow = "shrink";
        }
      };
      this.border = function () {
        if (this.x >= w || this.x <= 0) {
          this.d.x *= -1;
        }
        if (this.y >= h || this.y <= 0) {
          this.d.y *= -1;
        }
        this.x > w ? (this.x = w) : this.x;
        this.y > h ? (this.y = h) : this.y;
        this.x < 0 ? (this.x = 0) : this.x;
        this.y < 0 ? (this.y = 0) : this.y;
      };
      this.draw = function () {
        canvas.beginPath();
        canvas.arc(this.x, this.y, this.radius, 0, Math.PI * 2);

        var gradient = canvas.createRadialGradient(
          this.x,
          this.y,
          0,
          this.x,
          this.y,
          this.radius
        );
        gradient.addColorStop(0, "gray");
        gradient.addColorStop(1, "transparent");

        canvas.closePath();
        canvas.fillStyle = gradient;
        canvas.fill();
      };
    },
    checkDistance = function (x1, y1, x2, y2) {
      return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    },
    communicatePoints = function (point1, father) {
      for (var i = 0; i < father.length; i++) {
        var distance = checkDistance(
          point1.x,
          point1.y,
          father[i].x,
          father[i].y
        );
        var opacity = 1 - distance / opts.communicationRadius;
        if (opacity > 0) {
          canvas.lineWidth = opacity;
          canvas.strokeStyle = "rgba(255,255,255,0.5)";
          canvas.beginPath();
          canvas.moveTo(point1.x, point1.y);
          canvas.lineTo(father[i].x, father[i].y);
          canvas.shadowBlur = 0;
          canvas.closePath();
          canvas.stroke();
        }
      }
    };

  function setup() {
    for (var i = 0; i < opts.particleAmount; i++) {
      particles.push(new Particle());
    }
    window.requestAnimationFrame(loop);
  }

  function loop() {
    window.requestAnimationFrame(loop);
    tick++;

    canvas.clearRect(0, 0, w, h);

    for (var i = 0; i < particles.length; i++) {
      particles[i].update();
      particles[i].draw();
    }
    for (var a = 0; a < particles.length; a++) {
      communicatePoints(particles[a], particles);
    }
  }

  setup();

  window.addEventListener("resize", function () {
    w = canvasBody.width = window.innerWidth;
    h = canvasBody.height = window.innerHeight;
  });

  canvasBody.addEventListener("contextmenu", function (e) {
    e.preventDefault();
    particles.splice(particles.length - 1, 1);
  });
</script>
